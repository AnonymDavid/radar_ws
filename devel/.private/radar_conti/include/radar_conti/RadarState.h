// Generated by gencpp from file radar_conti/RadarState.msg
// DO NOT EDIT!


#ifndef RADAR_CONTI_MESSAGE_RADARSTATE_H
#define RADAR_CONTI_MESSAGE_RADARSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>
#include <std_msgs/UInt8.h>

namespace radar_conti
{
template <class ContainerAllocator>
struct RadarState_
{
  typedef RadarState_<ContainerAllocator> Type;

  RadarState_()
    : header()
    , radarstate_nvmwritestatus()
    , radarstate_nvmreadstatus()
    , radarstate_maxdistancecfg()
    , radarstate_persistent_error()
    , radarstate_interference()
    , radarstate_temperature_error()
    , radarstate_temporary_error()
    , radarstate_voltage_error()
    , radarstate_radarpowercfg()
    , radarstate_sortindex()
    , radarstate_sensorid()
    , radarstate_motionrxstate()
    , radarstate_sendextinfocfg()
    , radarstate_sendqualitycfg()
    , radarstate_outputtypecfg()
    , radarstate_ctrlrelaycfg()
    , radarstate_rcs_threshold()  {
    }
  RadarState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , radarstate_nvmwritestatus(_alloc)
    , radarstate_nvmreadstatus(_alloc)
    , radarstate_maxdistancecfg(_alloc)
    , radarstate_persistent_error(_alloc)
    , radarstate_interference(_alloc)
    , radarstate_temperature_error(_alloc)
    , radarstate_temporary_error(_alloc)
    , radarstate_voltage_error(_alloc)
    , radarstate_radarpowercfg(_alloc)
    , radarstate_sortindex(_alloc)
    , radarstate_sensorid(_alloc)
    , radarstate_motionrxstate(_alloc)
    , radarstate_sendextinfocfg(_alloc)
    , radarstate_sendqualitycfg(_alloc)
    , radarstate_outputtypecfg(_alloc)
    , radarstate_ctrlrelaycfg(_alloc)
    , radarstate_rcs_threshold(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_nvmwritestatus_type;
  _radarstate_nvmwritestatus_type radarstate_nvmwritestatus;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_nvmreadstatus_type;
  _radarstate_nvmreadstatus_type radarstate_nvmreadstatus;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_maxdistancecfg_type;
  _radarstate_maxdistancecfg_type radarstate_maxdistancecfg;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_persistent_error_type;
  _radarstate_persistent_error_type radarstate_persistent_error;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_interference_type;
  _radarstate_interference_type radarstate_interference;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_temperature_error_type;
  _radarstate_temperature_error_type radarstate_temperature_error;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_temporary_error_type;
  _radarstate_temporary_error_type radarstate_temporary_error;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_voltage_error_type;
  _radarstate_voltage_error_type radarstate_voltage_error;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_radarpowercfg_type;
  _radarstate_radarpowercfg_type radarstate_radarpowercfg;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_sortindex_type;
  _radarstate_sortindex_type radarstate_sortindex;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_sensorid_type;
  _radarstate_sensorid_type radarstate_sensorid;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_motionrxstate_type;
  _radarstate_motionrxstate_type radarstate_motionrxstate;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_sendextinfocfg_type;
  _radarstate_sendextinfocfg_type radarstate_sendextinfocfg;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_sendqualitycfg_type;
  _radarstate_sendqualitycfg_type radarstate_sendqualitycfg;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_outputtypecfg_type;
  _radarstate_outputtypecfg_type radarstate_outputtypecfg;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_ctrlrelaycfg_type;
  _radarstate_ctrlrelaycfg_type radarstate_ctrlrelaycfg;

   typedef  ::std_msgs::UInt8_<ContainerAllocator>  _radarstate_rcs_threshold_type;
  _radarstate_rcs_threshold_type radarstate_rcs_threshold;





  typedef boost::shared_ptr< ::radar_conti::RadarState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::radar_conti::RadarState_<ContainerAllocator> const> ConstPtr;

}; // struct RadarState_

typedef ::radar_conti::RadarState_<std::allocator<void> > RadarState;

typedef boost::shared_ptr< ::radar_conti::RadarState > RadarStatePtr;
typedef boost::shared_ptr< ::radar_conti::RadarState const> RadarStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::radar_conti::RadarState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::radar_conti::RadarState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::radar_conti::RadarState_<ContainerAllocator1> & lhs, const ::radar_conti::RadarState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.radarstate_nvmwritestatus == rhs.radarstate_nvmwritestatus &&
    lhs.radarstate_nvmreadstatus == rhs.radarstate_nvmreadstatus &&
    lhs.radarstate_maxdistancecfg == rhs.radarstate_maxdistancecfg &&
    lhs.radarstate_persistent_error == rhs.radarstate_persistent_error &&
    lhs.radarstate_interference == rhs.radarstate_interference &&
    lhs.radarstate_temperature_error == rhs.radarstate_temperature_error &&
    lhs.radarstate_temporary_error == rhs.radarstate_temporary_error &&
    lhs.radarstate_voltage_error == rhs.radarstate_voltage_error &&
    lhs.radarstate_radarpowercfg == rhs.radarstate_radarpowercfg &&
    lhs.radarstate_sortindex == rhs.radarstate_sortindex &&
    lhs.radarstate_sensorid == rhs.radarstate_sensorid &&
    lhs.radarstate_motionrxstate == rhs.radarstate_motionrxstate &&
    lhs.radarstate_sendextinfocfg == rhs.radarstate_sendextinfocfg &&
    lhs.radarstate_sendqualitycfg == rhs.radarstate_sendqualitycfg &&
    lhs.radarstate_outputtypecfg == rhs.radarstate_outputtypecfg &&
    lhs.radarstate_ctrlrelaycfg == rhs.radarstate_ctrlrelaycfg &&
    lhs.radarstate_rcs_threshold == rhs.radarstate_rcs_threshold;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::radar_conti::RadarState_<ContainerAllocator1> & lhs, const ::radar_conti::RadarState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace radar_conti

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::radar_conti::RadarState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::radar_conti::RadarState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_conti::RadarState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::radar_conti::RadarState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_conti::RadarState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::radar_conti::RadarState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::radar_conti::RadarState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "a2a8e3e1ff2df867bbb8f3f07e04a77f";
  }

  static const char* value(const ::radar_conti::RadarState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xa2a8e3e1ff2df867ULL;
  static const uint64_t static_value2 = 0xbbb8f3f07e04a77fULL;
};

template<class ContainerAllocator>
struct DataType< ::radar_conti::RadarState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "radar_conti/RadarState";
  }

  static const char* value(const ::radar_conti::RadarState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::radar_conti::RadarState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#  ------------------------------------------------------------------------\n"
"#\n"
"#  Name:       RadarState\n"
"#  Id:         0x201\n"
"#  Length:     8 bytes\n"
"#  Cycle time: 50 ms\n"
"#  Senders:    ARS_ISF\n"
"#  Layout:\n"
"#\n"
"#                          Bit\n"
"#\n"
"#             7   6   5   4   3   2   1   0\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#         0 |<-x|<-x|   |   |   |   |   |   |\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#             |   +-- RadarState_NVMReadStatus\n"
"#             +-- RadarState_NVMwriteStatus\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#         1 |<------------------------------|\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#         2 |------x|<-x|<-x|<-x|<-x|<-x|   |\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#                 |   |   |   |   |   +-- RadarState_Voltage_Error\n"
"#                 |   |   |   |   +-- RadarState_Temporary_Error\n"
"#                 |   |   |   +-- RadarState_Temperature_Error\n"
"#                 |   |   +-- RadarState_Interference\n"
"#                 |   +-- RadarState_Persistent_Error\n"
"#                 +-- RadarState_MaxDistanceCfg\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#     B   3 |   |   |   |   |   |   |<------|\n"
"#     y     +---+---+---+---+---+---+---+---+\n"
"#     t   4 |--x|<---------x|   |<---------x|\n"
"#     e     +---+---+---+---+---+---+---+---+\n"
"#             |           |               +-- RadarState_SensorID\n"
"#             |           +-- RadarState_SortIndex\n"
"#             +-- RadarState_RadarPowerCfg\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#         5 |<-----x|<-x|<-x|<-----x|<-x|   |\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#                 |   |   |       |   +-- RadarState_CtrlRelayCfg\n"
"#                 |   |   |       +-- RadarState_OutputTypeCfg\n"
"#                 |   |   +-- RadarState_SendQualityCfg\n"
"#                 |   +-- RadarState_SendExtInfoCfg\n"
"#                 +-- RadarState_MotionRxState\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#         6 |   |   |   |   |   |   |   |   |\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#         7 |   |   |   |<---------x|   |   |\n"
"#           +---+---+---+---+---+---+---+---+\n"
"#                                 +-- RadarState_RCS_Threshold\n"
"#\n"
"#  Signal tree:\n"
"#\n"
"#    -- {root}\n"
"#       +-- RadarState_NVMwriteStatus\n"
"#       +-- RadarState_NVMReadStatus\n"
"#       +-- RadarState_MaxDistanceCfg\n"
"#       +-- RadarState_Persistent_Error\n"
"#       +-- RadarState_Interference\n"
"#       +-- RadarState_Temperature_Error\n"
"#       +-- RadarState_Temporary_Error\n"
"#       +-- RadarState_Voltage_Error\n"
"#       +-- RadarState_RadarPowerCfg\n"
"#       +-- RadarState_SortIndex\n"
"#       +-- RadarState_SensorID\n"
"#       +-- RadarState_MotionRxState\n"
"#       +-- RadarState_SendExtInfoCfg\n"
"#       +-- RadarState_SendQualityCfg\n"
"#       +-- RadarState_OutputTypeCfg\n"
"#       +-- RadarState_CtrlRelayCfg\n"
"#       +-- RadarState_RCS_Threshold\n"
"#\n"
"#  ------------------------------------------------------------------------\n"
"#\n"
"std_msgs/Header header\n"
"std_msgs/UInt8 radarstate_nvmwritestatus\n"
"std_msgs/UInt8 radarstate_nvmreadstatus\n"
"std_msgs/UInt8 radarstate_maxdistancecfg\n"
"std_msgs/UInt8 radarstate_persistent_error\n"
"std_msgs/UInt8 radarstate_interference\n"
"std_msgs/UInt8 radarstate_temperature_error\n"
"std_msgs/UInt8 radarstate_temporary_error\n"
"std_msgs/UInt8 radarstate_voltage_error\n"
"std_msgs/UInt8 radarstate_radarpowercfg\n"
"std_msgs/UInt8 radarstate_sortindex\n"
"std_msgs/UInt8 radarstate_sensorid\n"
"std_msgs/UInt8 radarstate_motionrxstate\n"
"std_msgs/UInt8 radarstate_sendextinfocfg\n"
"std_msgs/UInt8 radarstate_sendqualitycfg\n"
"std_msgs/UInt8 radarstate_outputtypecfg\n"
"std_msgs/UInt8 radarstate_ctrlrelaycfg\n"
"std_msgs/UInt8 radarstate_rcs_threshold\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/UInt8\n"
"uint8 data\n"
;
  }

  static const char* value(const ::radar_conti::RadarState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::radar_conti::RadarState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.radarstate_nvmwritestatus);
      stream.next(m.radarstate_nvmreadstatus);
      stream.next(m.radarstate_maxdistancecfg);
      stream.next(m.radarstate_persistent_error);
      stream.next(m.radarstate_interference);
      stream.next(m.radarstate_temperature_error);
      stream.next(m.radarstate_temporary_error);
      stream.next(m.radarstate_voltage_error);
      stream.next(m.radarstate_radarpowercfg);
      stream.next(m.radarstate_sortindex);
      stream.next(m.radarstate_sensorid);
      stream.next(m.radarstate_motionrxstate);
      stream.next(m.radarstate_sendextinfocfg);
      stream.next(m.radarstate_sendqualitycfg);
      stream.next(m.radarstate_outputtypecfg);
      stream.next(m.radarstate_ctrlrelaycfg);
      stream.next(m.radarstate_rcs_threshold);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RadarState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::radar_conti::RadarState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::radar_conti::RadarState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "radarstate_nvmwritestatus: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_nvmwritestatus);
    s << indent << "radarstate_nvmreadstatus: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_nvmreadstatus);
    s << indent << "radarstate_maxdistancecfg: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_maxdistancecfg);
    s << indent << "radarstate_persistent_error: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_persistent_error);
    s << indent << "radarstate_interference: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_interference);
    s << indent << "radarstate_temperature_error: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_temperature_error);
    s << indent << "radarstate_temporary_error: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_temporary_error);
    s << indent << "radarstate_voltage_error: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_voltage_error);
    s << indent << "radarstate_radarpowercfg: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_radarpowercfg);
    s << indent << "radarstate_sortindex: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_sortindex);
    s << indent << "radarstate_sensorid: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_sensorid);
    s << indent << "radarstate_motionrxstate: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_motionrxstate);
    s << indent << "radarstate_sendextinfocfg: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_sendextinfocfg);
    s << indent << "radarstate_sendqualitycfg: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_sendqualitycfg);
    s << indent << "radarstate_outputtypecfg: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_outputtypecfg);
    s << indent << "radarstate_ctrlrelaycfg: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_ctrlrelaycfg);
    s << indent << "radarstate_rcs_threshold: ";
    s << std::endl;
    Printer< ::std_msgs::UInt8_<ContainerAllocator> >::stream(s, indent + "  ", v.radarstate_rcs_threshold);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RADAR_CONTI_MESSAGE_RADARSTATE_H
